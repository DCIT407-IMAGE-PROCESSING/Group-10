# Comparative Analysis of Noise Removal Techniques for Different Noise Models

## 1. Introduction

Digital images are widely used in medical imaging, satellite imaging, surveillance systems, and photography. However, during image acquisition, transmission, or storage, images often become corrupted by unwanted disturbances known as **image noise**.

Image noise reduces visual quality and may hide important details such as edges and textures. Therefore, noise removal is an essential task in **digital image processing**.

This project performs a **comparative analysis of noise removal techniques for different noise models**. The objective is to evaluate how different filtering techniques perform when applied to various types of noise using both visual inspection and quantitative evaluation metrics.


## 2. Causes of Image Noise

Image noise can occur due to several practical factors:

### Sensor Limitations

Image sensors are not perfect and may introduce small random errors when converting light into electrical signals. These errors appear as random pixel intensity variations. This commonly produces **Gaussian noise**.

### Poor Lighting Conditions

In low-light environments, cameras increase signal amplification (ISO), which also amplifies unwanted electrical fluctuations. This creates grainy textures in images. The result is usually **Gaussian-type noise**.

### Transmission Errors

During image transmission, data bits may become corrupted. This can randomly change pixel values to extreme values (black or white). This typically produces **Salt-and-Pepper (impulse) noise**.

### Electronic Interference

Electrical disturbances from nearby devices can affect image signals during capture. These disturbances introduce random intensity changes in pixels, often resulting in **Gaussian noise**.


## 3. Noise Theory

### General Noise Model

A noisy image can be represented as:

$[
I_{noisy} = I_{original} + N
]$

Where:

* ( I_{original} ) = original image
* ( N ) = noise component



### 3.1 Gaussian Noise

Gaussian noise follows a **normal distribution**.

$[
I_{noisy}(x,y) = I(x,y) + N(0, \sigma^2)
$

Where:

* ( \sigma^2 ) = variance controlling noise strength

**Creation:**
Gaussian noise is generated using random values from a normal distribution and added to each pixel. It affects all pixels in the image.

**Characteristics:**

* Appears as grainy texture
* Distributed across the entire image
* Common in low-light photography



### 3.2 Salt-and-Pepper Noise

Salt-and-pepper noise is also known as **impulse noise**.

$[
I_{noisy}(x,y) =
\begin{cases}
0 & \text{with probability } p_1 \
255 & \text{with probability } p_2 \
I(x,y) & \text{otherwise}
\end{cases}
]$

**Creation:**
Random pixels are selected and replaced with 0 (black) or 255 (white). Only a percentage of pixels are affected.

**Characteristics:**

* Appears as white and black dots
* Caused by transmission errors
* Does not affect all pixels

---

### 3.3 Speckle Noise

Speckle noise is **multiplicative noise**.

$[
I_{noisy}(x,y) = I(x,y) + I(x,y) \cdot N
]$

**Creation:**
Speckle noise is generated by multiplying pixel values with random noise. Since it depends on pixel intensity, it is called multiplicative noise.

**Characteristics:**

* Common in ultrasound and radar imaging
* Intensity-dependent
* Produces rough textures


## 4. Filter Theory

Filtering reduces noise by modifying pixel values using neighboring pixel information.



### 4.1 Mean (Averaging) Filter

$[
I'(x,y) = \frac{1}{mn} \sum I(x+i, y+j)
]$

The mean filter replaces each pixel with the average of its neighbors.

**Why it works for Gaussian Noise:**
Gaussian noise affects all pixels slightly. Averaging reduces small random variations, making the image smoother.



### 4.2 Median Filter

$[
I'(x,y) = \text{median} { I(x+i, y+j) }
]$

The median filter replaces a pixel with the median value in its neighborhood.

**Why it works for Salt-and-Pepper Noise:**
Salt-and-pepper noise introduces extreme pixel values (0 or 255). The median filter removes these outliers without blurring edges.



### 4.3 Gaussian Filter

$[
G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}
]$

The Gaussian filter applies weighted smoothing based on a Gaussian function.

**Why it works for Gaussian Noise:**
Since Gaussian noise follows a normal distribution, Gaussian smoothing effectively reduces it while preserving image structure better than simple averaging.



### 4.4 Bilateral Filter

The bilateral filter considers both spatial closeness and intensity similarity.

$[
I'(x) = \frac{1}{W_p} \sum G_s(||x_i - x||) , G_r(||I(x_i) - I(x)||) , I(x_i)
]$

**Why it works for Gaussian Noise:**
It smooths pixel values while preserving edges. This makes it effective for reducing Gaussian noise without blurring important image boundaries.



## 5. Performance Evaluation

To compare performance objectively, we use **quantitative metrics** rather than relying only on visual inspection.

We compare:

* How much noise is removed
* How close the filtered image is to the original image
* How well edges and details are preserved



### 5.1 Mean Squared Error (MSE)

$[
MSE = \frac{1}{MN} \sum [I(x,y) - I'(x,y)]^2
]$

MSE measures the average squared difference between the original and filtered image.

**Lower MSE = Better Quality**
A lower MSE means the filtered image is closer to the original image, indicating effective noise removal.



### 5.2 Peak Signal-to-Noise Ratio (PSNR)

$[
PSNR = 10 \log_{10} \left( \frac{MAX^2}{MSE} \right)
]$

Where ( MAX = 255 ) for 8-bit images.

**Higher PSNR = Better Quality**
A higher PSNR indicates less distortion and better restoration quality.



## 6. Methodology

The methodology of this project consists of the following steps:

### Step 1: Image Acquisition

Real or publicly available images are selected and preprocessed.

### Step 2: Noise Simulation

Gaussian noise, Salt-and-Pepper noise, and Speckle noise are added separately to the original image.

### Step 3: Noise Removal

Each noisy image is filtered using:

* Mean filter
* Median filter
* Gaussian filter
* Bilateral filter

### Step 4: Performance Evaluation

For each filtered result:

* MSE is calculated
* PSNR is computed
* Results are recorded in a comparison table

### Step 5: Comparative Analysis

The effectiveness of each filter is analyzed based on:

* Visual quality
* MSE values
* PSNR values
* Edge preservation



# Discussion
In this project, we evaluated the performance of Mean and Gaussian filters in removing different types of noise from grayscale images. Three noise models were tested: Gaussian noise, Salt & Pepper noise, and Speckle noise.

From the quantitative results, the Gaussian filter achieved higher PSNR values than the Mean filter for Gaussian noise and Salt & Pepper noise. This is expected because the Gaussian filter uses weighted averaging, which aligns well with the statistical distribution of Gaussian noise. The weighted smoothing reduces noise while preserving more structural details compared to simple averaging.

For Speckle noise, however, the Mean filter performed slightly better than the Gaussian filter in terms of PSNR. Speckle noise is multiplicative in nature, and both filters struggled to fully restore the image. This indicates that linear smoothing filters may not be optimal for multiplicative noise, and more advanced techniques such as median filtering or adaptive filters could produce better results.

Visually, both filters reduced noise but introduced blurring. Increasing the kernel size would remove more noise but also increase detail loss. Therefore, a trade-off exists between noise reduction and edge preservation.

## Strengths of this approach include:
- Simple implementation using spatial domain filtering.
- Clear quantitative evaluation using MSE and PSNR.
- Direct visual comparison of results.
- Both filters are computationally efficient and easy to implement using OpenCV. They are excellent for removing low-level additive noise and preparing images for edge detection.

## Limitations include:
- Only linear filters were tested.
- Evaluation was performed on a single image.
- Both methods are low-pass filters, meaning they inherently blur edges. They cannot distinguish between high-frequency noise and high-frequency edge details.

## Real World Application
- Pre-processing for OCR: Smoothing document scans to improve text recognition.
- Privacy Masking: Blurring faces or license plates in datasets.
- Medical Imaging: Reducing graininess in X-rays or Ultrasound frames before diagnostic analysis.
  
In real-world applications such as medical imaging and satellite image analysis, selecting the appropriate filter depends on the noise characteristics of the acquisition system. This experiment demonstrates that understanding the statistical nature of noise is essential for choosing the correct denoising method.

